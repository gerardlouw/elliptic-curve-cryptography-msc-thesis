Suppose Alice would like to send a message $m \in \msgs$ to Bob over a public network, along with a \emph{signature} which proves that the message has not been tampered with during transit. This is the problem solved by a \emph{signature scheme}, which provides a \emph{signing} algorithm which Alice may use to generate a signature for some message, and a \emph{verification} algorithm which Bob may use to ensure that the message which he receives is the same as the message sent by Alice. For this to be possible, it must be difficult for a third party to forge Alice's signature for some message given examples of her signatures for other messages.

We describe a cryptosystem known as the \emph{Schnorr signature scheme} due to \citep{Schnorr}. For Alice to sign a message $m$ that she wishes to send to Bob, she randomly selects an emphemeral key $e \in \F_\ell$, computes the point multiplication $[e] G$, and sets the first part of her signature to the hash $s_1 \defeq H(m, [e] G)$. The second part of her signature is simply computed as $s_2 \defeq e - s_A s_1$. Finally, the signature is appended to the message, yielding the tuple $(m, s_1, s_2)$. Sage code for this procedure is given in \cref{alg:schnorr_sign}.

%TODO if h = 0, we do not have a uniform distribution. what do? pick a new ephemeral key

\begin{alg}{Schnorr signing}{schnorr_sign}
\begin{sagecode}
def schnorr_sign(m, s_A, G, l):
    """
    m: the message
    s_A: Alice's secret key
    G: the base point
    l: the order of G
    """
    e = randint(0, l - 1)
    s_1 = hash((m, e * G)) % l
    s_2 = (e - s_A * s_1) % l
    return m, s_1, s_2
\end{sagecode}
\end{alg}

Assuming that the hash function $H$ is secure against inversion, it is not possible to gain knowledge of $e$ from $s_1$. Furthermore, assuming $s_1$ is indistinguishable from a randomly selected element of $\F_\ell$ without knowledge of $e$, it is impossible to learn $s_A$ from $s_2$. Someone who does not have knowledge of Alice's private key $s_A$ can construct a valid value for $s_1$ corresponding to $m$ by choosing their own ephemeral key $e'$. However, they will not be able to construct a matching value for $s_2$ without knowledge of $s_A$, so that Alice's signatures cannot be forged.

To verify that the signature $(s_1, s_2)$ corresponds to the message $m$ that was sent by Alice, Bob may do the following. He computes the point multiplications $[s_1] K_A$ and $[s_2] G$, then evaluates the hash $H(m, [s_1] K_A + [s_2] G)$. If this is equal to $s_1$, then he accepts that the message has been verified. Otherwise, he rejects it. This verification algorithm is given as Sage code in $\cref{alg:schnorr_verify}$. %TODO shamir's trick, compute aX + bY more efficiently

\begin{alg}{Schnorr verification}{schnorr_verify}
\begin{sagecode}
def schnorr_verify((m, s_1, s_2), K_A, G, l):
    """
    m: the message
    (s_1, s_2): the signature
    K_A: Alice's public key
    G: the base point
    l: the order of G
    """
    return s_1 == hash((m, s_1 * K_A + s_2 * G)) % l
\end{sagecode}
\end{alg}

Since $[s_2] G = [e] G - [s_A s_1] G = [e] G - [s_1] K_A$, we have that $[s_1] K_A + [s_2] G = [e] G$, showing that the verification procedure works for signatures generated by \cref{alg:schnorr_sign}. Furthermore, assuming that the hash function $H$ is resistant against collisions, it is not possible to pick a different message $m'$ such that $H(m', [s_1] K_A + [s_2] G)$ will evaluate to $s_1$.

Note that the Schnorr signature scheme does not rely on the Diffie-Hellman problem, although it does implicitly rely on the discrete logarithm problem due to the nature of Diffie-Hellman key pairs.
%TODO actually give the properties of cryptographic hash functions somewhere - non-invertibile, indistinguishable from random numbers, collision-resistant
%TODO breaking hash collision allows replacing m with some other message m', but forgery requires breaking discrete log

%TODO Schnorr signatures can also be easily extended to allow the signing of a single message $m$ by multiple parties, yielding a single signature.
